# Модель работы с транзакциями в datapipe

## Зачем это надо

По итогам трейсинга времени выполнения выяснилось, что подавляющее количество
времени (50% в случае `examples/one_to_many_pipeline`) приходится на блок
`store_chunk`.

Самой сильной гипотезой, которая объясняла потери времени оказалась логика
работы SQLAlchemy, которая по умолчанию (при работе через engine напрямую
включает режим `autocommit`).

Если завернуть всю работу с данными в транзакцию, то скорость записи значительно
возрастает.

Поэтому, кажется, что введение транзакционной работы с БД в `datapipe` - неизбежно.

## Обзор текущего состояния

В `datapipe` есть два вида баз, которые подлежат более четкому контролю с точки
зрения транзакций:

1. meta-таблицы
1. таблицы, которые хранятся через класс `TableStoreDB`

Для доступа и к 1 и 2 используется класс `DBConn` который абстрагирует реквизиты
доступа.

Случаи, которые хочется корректно отрабатывать:

1. Мета-таблица в базе А и дата-таблица в базе А
1. Мета-таблица в базе А и дата-таблица в базе Б
1. Мета-таблица в базе А, дата-таблица в базе А и дата-таблица в базе Б

На текущий момент класс `DBConn` всегда позволяет обратиться к базе, так как
открывает соединение сразу же при создании объекта.

## Реализация

Основное изменение:

`DBConn` становится модальным объектом. За пределами транзакции получить доступ
к БД нельзя.

Транзакция открывается с помощью контекстного менеджера `dbconn_transactions`,
он мутирует каждый переданный в него `dbconn`: открывает соединение и начинает
транзакцию в начале контекста и закрывает транзакцию в конце контекста.

`dbconn_transactions` предусматривает возможность вложенных вызовов (при
открытой транзакции к базе А, снова сделать вызов для открытия транзакции в А),
приоритет отдается более внешней транзакции.

Так как не все `TableStore` работают с базой, так же реализован вспомогательный
метод `DataStore.transaction`, который принимает списки `DataTable` и сам
находит те `TableStore` которые работают с БД и требуют открытия транзакции.

